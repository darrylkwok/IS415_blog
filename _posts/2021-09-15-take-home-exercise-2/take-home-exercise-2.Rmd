---
title: "Take-Home Exercise 2"
description: |
  A short description of the post.
author:
  - name: Darryl Kwok
    url: https://example.com/darrylkwok
date: 09-15-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE, eval=TRUE, echo=TRUE, message=FALSE, error=FALSE, fig.retina=3}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

## Installing and launching the R packages

```{r}
packages = c('sp', 'rgdal', 'spNetwork', 'tmap', 'maptools', 'sf', 'raster', 'spatstat', 'tidyverse', 'plotly', 'ggthemes')
for (p in packages){
if(!require(p, character.only = T)){
install.packages(p)
}
library(p,character.only = T)
}
```



# Data

## Import Geospatial Data

```{r}
train_services_sf <- st_read(dsn="data/geospatial", layer="MRTLRTStnPtt")
mpsz_sf <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_WEB_PL")
sg_sf <- st_read(dsn = "data/geospatial", layer="CostalOutline")
```

## Geospatial Data Preparation

### Check the detailed information of the geospatial data

```{r}
st_crs(train_services_sf)
st_crs(mpsz_sf)
st_crs(sg_sf)
```

We can see from these 3 st_crs() outputs that, the projections are in SVY21, however the EPSG code is 9001. The correct EPSG code is 3414. 

Therefore, we will assign the correct EPSG code.

```{r}
train_services_sf <- st_set_crs(train_services_sf, 3414)
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
sg_sf <- st_set_crs(sg_sf, 3414)
```

Check the crs of the 3 geospatial data again to confirm the changes

```{r}
st_crs(train_services_sf)
st_crs(mpsz_sf)
st_crs(sg_sf)
```

Check if the geometries are valid for the train_services_sf 

```{r}
length(which(st_is_valid(train_services_sf) == FALSE))
```

From the above output, we can see that there are no invalid geometries for the train_services_sf

Check if the geometries are valid for the mpsz_sf

```{r}
length(which(st_is_valid(mpsz_sf) == FALSE))
```

From the above output, we can see that there are 9 invalid geometries in the mpsz data

Therefore, we will handle the invalid geometries and check if the changes are made.

```{r}
mpsz_sf <- st_make_valid(mpsz_sf)
length(which(st_is_valid(mpsz_sf) == FALSE))
```

Check if the geometries are valid for the sg_sf

```{r}
length(which(st_is_valid(sg_sf) == FALSE))
```

From the above output, we can see that there are 1 invalid geometries in the sg data

Therefore, we will handle the invalid geometries and check if the changes are made.

```{r}
sg_sf <- st_make_valid(sg_sf)
length(which(st_is_valid(sg_sf) == FALSE))
```


### Visualise the Location of the Train Services on the Singapore Map

```{r}
tmap_mode('view')

tm_shape(train_services_sf) +
  tm_dots(col="red", size=0.1)

tmap_mode('plot')
```


## Import Aspatial Data

```{r}
june_2019 <- read_csv("data/aspatial/30062019.csv")
june_2021 <- read_csv("data/aspatial/30062021.csv")
hotels <- read_csv("data/aspatial/hotels.csv")
tourism <- read_csv("data/aspatial/tourism.csv")
``` 

## Aspatial Data Preparation

### Learn more about each of the aspatial datasets

```{r}
glimpse(june_2019)
```

```{r}
glimpse(june_2021)
```

```{r}
glimpse(hotels)
```

```{r}
glimpse(tourism)
```

After using the glimpse() function on all the aspatial data, there are a few observations:

  - All of the data uses Longitude and Latitude or Lng and Lat for the column names
  - The Longitude and Latitude of all the data are projected in the 4326 projection system
  

### Check if there are rows that have missing values in june_2019 dataframe longtitude or latitude columns

```{r}
sum(is.na(june_2019$latitude))
sum(is.na(june_2019$longitude))
```

### Check if there are rows that have missing values in june_2021 dataframe longtitude or latitude columns

```{r}
sum(is.na(june_2021$latitude))
sum(is.na(june_2021$longitude))
```

### Check if there are rows that have missing values in hotels dataframe longtitude or latitude columns

```{r}
sum(is.na(hotels$Lng))
sum(is.na(hotels$Lat))
```

### Check if there are rows that have missing values in tourism dataframe longtitude or latitude columns

There are 2 geographic coordinates in the tourism dataframe

```{r}
sum(is.na(tourism$LONGTITUDE))
sum(is.na(tourism$LATITUDE))
```
```{r}
sum(is.na(tourism$Lat))
sum(is.na(tourism$Lng))
```

We can see that the LONGTITUDE and LATITUDE columns contains missing values but the Lat and Lng columns contains no missing values.

### Extract the row that contains missing values in the LONGTITUDE and LATITUDE columns

```{r}
tourism[(is.na(tourism$LONGTITUDE) | tourism$LONGTITUDE=="" | is.na(tourism$LATITUDE) | tourism$LATITUDE == ""), ]
```

Although Crusises from Singapore is a tourism activity, it does not belong to a specific location on the map. Therefore we will remove it from the dataframe. This is because having 0,0 coordinates can many different meanings in Geospatial Data

```{r}
tourism <- tourism[!(is.na(tourism$LONGTITUDE) | tourism$LONGTITUDE=="" | is.na(tourism$LATITUDE) | tourism$LATITUDE == ""), ]
```

Check if the row is removed from the dataframe

```{r}
tourism[(is.na(tourism$LONGTITUDE) | tourism$LONGTITUDE=="" | is.na(tourism$LATITUDE) | tourism$LATITUDE == ""), ]
```


### Convert the R Dataframes into sf objects and transform the coordinate projection system

Steps Taken:

  - Convert the R Dataframes into an sf object by defining the columns and the projection system
  - Then transform the projection system to the correct one

```{r}
june_2019_sf <- st_as_sf(june_2019, coords = c("longitude", "latitude"), crs = 4326) %>%
  st_transform(crs=3414)

june_2021_sf <- st_as_sf(june_2021, coords = c("longitude", "latitude"), crs = 4326) %>%
  st_transform(crs=3414)

hotels_sf <- st_as_sf(hotels, coords = c("Lng", "Lat"), crs = 4326) %>%
  st_transform(crs=3414)

tourism_sf <- st_as_sf(tourism, coords = c("Lng", "Lat"), crs = 4326) %>%
  st_transform(crs=3414)
```


```{r}
tmap_mode('view')

tm_shape(mpsz_sf) + 
  tm_polygons() +
tm_shape(tourism_sf) +
  tm_dots(col="red", size=0.1)

tmap_mode('plot')
```


## Geospatial and Aspatial Data Wrangling 

### Converting sf dataframes into sp Spatial Class

```{r}
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
train_services <-as_Spatial(train_services_sf)
june_2019 <- as_Spatial(june_2019_sf)
june_2021 <- as_Spatial(june_2021_sf)
hotels <- as_Spatial(hotels_sf)
tourism <- as_Spatial(tourism_sf)
```

Display the information about the Spatial Classes 

```{r}
mpsz
```

```{r}
sg
```

```{r}
train_services
```

```{r}
june_2019
```

```{r}
june_2021
```

```{r}
hotels
```

```{r}
tourism
```

### Converting the Spatial class into generic sp format

```{r}
mpsz_sp <- as(mpsz, "SpatialPolygons")
sg_sp <- as(sg, "SpatialPolygons")
train_services_sp <-as(train_services, "SpatialPoints")
june_2019_sp <- as(june_2019, "SpatialPoints")
june_2021_sp <- as(june_2021, "SpatialPoints")
hotels_sp <- as(hotels, "SpatialPoints")
tourism_sp <- as(tourism, "SpatialPoints")
```

Display the information about the sp objects

```{r}
mpsz_sp
```

```{r}
sg_sp
```

```{r}
train_services_sp
```

```{r}
june_2019_sp
```

```{r}
june_2021_sp
```

```{r}
hotels_sp
```

```{r}
tourism_sp
```

### Converting the sp objects into spatstat's ppp format

Difference between sp classes and ppp objects:

  - ppp objects include the boundary of the region where the point data have been observed, while sp classes do not

```{r}
train_services_ppp <-as(train_services_sp, "ppp")
june_2019_ppp <- as(june_2019_sp, "ppp")
june_2021_ppp <- as(june_2021_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
tourism_ppp <- as(tourism_sp, "ppp")
```

Take a quick look at all the ppp objects summary information

```{r}
summary(train_services_ppp)
```

For *train_services_ppp* there are no duplicated points

```{r}
summary(june_2019_ppp)
```

For *june_2019_ppp* there are duplicated points

```{r}
summary(june_2021_ppp)
```

For *june_2021_ppp* there are duplicated points

```{r}
summary(hotels_ppp)
```

For *hotels_ppp* there are duplicated points

```{r}
summary(tourism_ppp)
```

For *tourism_ppp* there are duplicated points

From the above summaries, we can see that other than *train_services_ppp*, all the other ppp objects contain duplicated points.

### Handling duplicated points

Confirm that there are duplicated points in the ppp objects using the **any()** and **duplicated()** functions

```{r}
any(duplicated(train_services_ppp)) 
```

```{r}
any(duplicated(june_2019_ppp)) 
```

```{r}
any(duplicated(june_2021_ppp)) 
```

```{r}
any(duplicated(hotels_ppp)) 
```

```{r}
any(duplicated(tourism_ppp)) 
```

It is always unclear on how to handle duplicates with Spatial Point Pattern Analysis.

One of the major consideration is that, if we delete the duplicate points, we might ignore things such as repeat occurrences at a certain place. It will cause us to lost valuable data.

Therefore, we will make each point "unique" by adding an attribute to the data that contains duplicate points:

  - *june_2019_ppp*
  - *june_2021_ppp*
  - *hotels_ppp*
  - *tourism_ppp*

```{r}
june_2019_ppp_jit <- rjitter(june_2019_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

june_2021_ppp_jit <- rjitter(june_2021_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

hotels_ppp_jit <- rjitter(hotels_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)

tourism_ppp_jit <- rjitter(tourism_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

After using jitter to the duplicated points, we will check if the changes were effected.

```{r}
any(duplicated(june_2019_ppp_jit)) 
```

```{r}
any(duplicated(june_2021_ppp_jit)) 
```

```{r}
any(duplicated(hotels_ppp_jit)) 
```

```{r}
any(duplicated(tourism_ppp_jit)) 
```
## Creating an owin object

Point pattern is defined as a series of events in a given area or window of observation. Therefore, it is important to define the observation window or area.

sg_sp is the CoastalOutline of Singapore. This will be the observation window we will be using.

```{r}
sg_owin <- as(sg_sp, "owin")
```

Display the output object using plot()

```{r}
plot(sg_owin)
```


## Combine Spatial Point Events and owin object

We will extract events that are specific to Singapore.This events include:

  - Airbnb Listings in June 2019
  - Airbnb Listing in June 2021
  - Tourism Attractions
  - Hotel Locations
  - Train services

```{r}
june_2019_SG_ppp = june_2019_ppp[sg_owin]

summary(june_2019_SG_ppp)
```

```{r}
june_2021_SG_ppp = june_2021_ppp[sg_owin]

summary(june_2021_SG_ppp)
```

```{r}
tourism_SG_ppp = tourism_ppp[sg_owin]

summary(tourism_SG_ppp)
```

```{r}
hotels_SG_ppp = hotels_ppp[sg_owin]

summary(hotels_SG_ppp)
```

```{r}
train_services_SG_ppp = train_services_ppp[sg_owin]

summary(train_services_SG_ppp)
```

Visualise each of the newly derived ppp objects that are confined to Singapore's boundaries

```{r}
plot(june_2019_SG_ppp)
```

```{r}
plot(june_2021_SG_ppp)
```

```{r}
plot(tourism_SG_ppp)
```

```{r}
plot(hotels_SG_ppp)
```

```{r}
plot(train_services_SG_ppp)
```

# Exploratory Spatial Data Analysis

## Kernel Density Estimation

**We want to compute number of points per square kilometer**

### Convert the unit of measurement to kilometers 

Since SVY21 uses meters as a unit of measurement, we will convert it to kilometers using the rescale() function

```{r}
june_2019_SG_ppp_km <- rescale(june_2019_SG_ppp, 1000, 'km')
june_2021_SG_ppp_km <- rescale(june_2021_SG_ppp, 1000, 'km')
tourism_SG_ppp_km <- rescale(tourism_SG_ppp, 1000, 'km')
hotels_SG_ppp_km <- rescale(hotels_SG_ppp, 1000, 'km')
train_services_SG_ppp_km <- rescale(train_services_SG_ppp, 1000, 'km')
```

### Compute Kernel Density Estimation using automatic bandwidth selection method

```{r}
kde_june_2019_SG_bw <- density(june_2019_SG_ppp_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                            kernel="gaussian") 

kde_june_2021_SG_bw <- density(june_2021_SG_ppp_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                            kernel="gaussian")

kde_tourism_SG_bw <- density(tourism_SG_ppp_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                            kernel="gaussian")

kde_hotels_SG_bw <- density(hotels_SG_ppp_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                            kernel="gaussian")

kde_train_services_SG_bw <- density(train_services_SG_ppp_km,
                              sigma=bw.ppl,
                              edge=TRUE,
                            kernel="gaussian")
```

### Plot the Kernel Density Estimation for:
  - Airbnb Listings in June 2019
  - Airbnb Listing in June 2021
  - Tourism Attractions
  - Hotel Locations
  - Train services


```{r}
plot(kde_june_2019_SG_bw)
```

```{r}
plot(kde_june_2019_SG_bw)
```

```{r}
plot(kde_june_2021_SG_bw)
```

```{r}
plot(kde_tourism_SG_bw)
```

```{r}
plot(kde_hotels_SG_bw)
```

```{r}
plot(kde_train_services_SG_bw)
```

### Converting KDE output into RasterLayer Object

The steps taken will be:

  - Convert the KDE outputs into a SpatialGridDataFrame
  - Convert the SpatialGridDataFrame into RasterLayer objects

In order for us to use the tmap package to map the RasterLayer objects, we have to include the CRS information.

Since we rescaled the coordinates to kilometers earlier, we have to rescale it back to meters in order for it to match the SVY21's unit of measurement of meters.

```{r}

kde_june_2019_SG_bw_raster <- kde_june_2019_SG_bw %>% 
  rescale(., 0.001, "m") %>%
  as.SpatialGridDataFrame.im() %>% 
  raster()

kde_june_2021_SG_bw_raster <- kde_june_2021_SG_bw %>% 
  rescale(., 0.001, "m") %>%
  as.SpatialGridDataFrame.im() %>% 
  raster()

kde_hotels_SG_bw_raster <- kde_hotels_SG_bw %>% 
  rescale(., 0.001, "m") %>%
  as.SpatialGridDataFrame.im() %>% 
  raster()

kde_tourism_SG_bw_raster <- kde_tourism_SG_bw %>% 
  rescale(., 0.001, "m") %>%
  as.SpatialGridDataFrame.im() %>% 
  raster()

kde_train_services_SG_bw_raster <- kde_train_services_SG_bw %>% 
  rescale(., 0.001, "m") %>%
  as.SpatialGridDataFrame.im() %>% 
  raster()
```

Check the properties of the RasterLayer Objects

```{r}
kde_june_2019_SG_bw_raster
```


```{r}
kde_june_2021_SG_bw_raster
```


```{r}
kde_hotels_SG_bw_raster
```


```{r}
kde_tourism_SG_bw_raster
```


```{r}
kde_train_services_SG_bw_raster
```

From the above outputs, we can see that the CRS property of the RasterLayer Objects are NA.

### Assigning Projection Systems

Assign CRS 3414 to all the RasterLayer objects and check the outputs

```{r}
projection(kde_june_2019_SG_bw_raster) <- CRS('+init=EPSG:3414')
kde_june_2019_SG_bw_raster
```

```{r}
projection(kde_june_2021_SG_bw_raster) <- CRS('+init=EPSG:3414')
kde_june_2021_SG_bw_raster
```

```{r}
projection(kde_hotels_SG_bw_raster) <- CRS('+init=EPSG:3414')
kde_hotels_SG_bw_raster
```

```{r}
projection(kde_tourism_SG_bw_raster) <- CRS('+init=EPSG:3414')
kde_tourism_SG_bw_raster
```

```{r}
projection(kde_train_services_SG_bw_raster) <- CRS('+init=EPSG:3414')
kde_train_services_SG_bw_raster
```
Create a function to plot the Density Maps

```{r}
density_map <- function(raster_object, mtitle) {
  tm_basemap('OpenStreetMap') +
tm_shape(raster_object) +
  tm_raster('v') + 
  tm_layout(legend.position = c('right', 'bottom'), 
            frame = FALSE, 
            main.title = mtitle,
            main.title.position = 'center',
            main.title.size = 1)

} 
```


```{r}
june_2019_dmap <- density_map(kde_june_2019_SG_bw_raster, mtitle = "June 2019 SG Airbnb Listings Density Map")
june_2021_dmap <- density_map(kde_june_2021_SG_bw_raster, mtitle = "June 2021 SG Airbnb Listings Density Map")
hotels_dmap <- density_map(kde_hotels_SG_bw_raster, mtitle = "SG Hotels Density Map")
tourism_dmap <- density_map(kde_tourism_SG_bw_raster, mtitle = "SG Tourism Attractions Density Map")
train_services_dmap <- density_map(kde_train_services_SG_bw_raster, mtitle = "SG Train Services Density Map")
```

```{r}
june_2019_dmap
```

```{r}
june_2021_dmap
```

```{r}
hotels_dmap
```

```{r}
tourism_dmap
```

```{r}
train_services_dmap
```





















